# 一. 前言

## 1.1 分布式架构与系统

1. 什么是分布式架构？

   ​		分布式系统是若干独立系统的集合,但是用户使用起来像是在使用一套系统。

2. 为什么需要分布式系统？

   ​		规模的逐步扩大和业务的复杂，单台计算机扛不住双十一那样的流量，俗话说：三个臭皮匠抵一个诸葛亮。



## 1.2 应用架构的发展演变

### 1.2.1 单体架构

* 什么是单体架构？

  ![image-20250516155209699](F:\JavaCode\Dubbo\document\image\image-20250516155209699.png)

  * 当网站流量很小的时候,我们将所有的应用(业务)放到一台服务器上,打包运行。例如公司管理系统和超市网银系统。

* 优点：开发简单，部署简单

* 缺点

  1. **热点问题**：某个子系统（web门户系统）访问量大，导致其他子系统的访问出现问题
  2. **扩展性差**，**新资源的分配粒度不精确**：门户系统访问量大，增加机器，增加服务器tomcat。但是新增的资源，不能精确给到后台。
  3. **模块（子系统）耦合度高、相互影响**：修改某一个子系统的代码，产生了问题，影响其他的子系统
  4. **维护部署成本高**：某次发布，只更新了后台管理的订单模块，但是因为是单体架构，所以会发布整个系统。
  5. **技术栈受限**：必须使用相同的编程语言开发不同的子系统。



### 1.2.2 水平扩展(集群架构)

* 什么是集群架构？

  ![image-20250516155935646](F:\JavaCode\Dubbo\document\image\image-20250516155935646.png)

  ​		将应用部署在多台服务器上，搭建集群。每个服务器的应用和功能是完全一样的。通过负载均衡器来决定用户访问哪个服务器。

* 与单体架构相比的优点：

  1. **提高了系统的稳定性：**一台节点出现问题，不会影响整个系统
  2. **提高系统的硬件支撑**：一个服务器的硬件是有上限的，多个服务器就提高了硬件的上限
  3. **提高了系统的并发能力**

* 水平扩展没有解决单体架构的问题，缺点还是存在。

  1. **热点问题**：原来web门户是热点，水平扩展之后web门户还是热点，资源还是大多分给了web门户。
  2. **扩展性差**，**新资源的分配粒度不精确**
  3. **模块（子系统）耦合度高、相互影响**
  4. **维护部署成本高**
  5. **技术栈受限**



### 1.2.3 垂直架构

* 什么是垂直架构？

  ​		将大应用拆分成为小应用(一般按照业务拆分),根据不同的访问频率决定各自业务部署的服务器数量。多个子系统(小应用)共享数据库等资源。

![image-20250516160325408](F:\JavaCode\Dubbo\document\image\image-20250516160325408.png)



### 1.2.4 RPC架构

* 什么是RPC架构?
  * 由垂直架构演变而来
  * 解决的事子系统间模块功能的调用，Service调用Service的问题。

![image-20250516161312496](F:\JavaCode\Dubbo\document\image\image-20250516161312496.png)

​		将业务拆分后,用某种方式实现各个业务模块的远程调用和复用,这时一个好的 RPC 框架就决定了你的分布式架构的性能,怎么调用,何时调用,服务器挂了怎么办......我们需要一个框架来帮我们解决这个问题(当然大大神可以自己写一个,但是应对大流量的成功者莫过于中国的阿里巴巴公司,顶住了淘宝双十一的流量,反观一些学校内部的选课系统,对于大流量时只有两个字--宕机)。

* RPC架构存在的问题

  ![image-20250516161612080](F:\JavaCode\Dubbo\document\image\image-20250516161612080.png)



### 1.2.5 SOA架构

* 什么是SOA架构？

  ![image-20250516163150574](F:\JavaCode\Dubbo\document\image\image-20250516163150574.png)

  ​		SOA（Service-Oriented Architecture，**面向服务的架构**）是一种软件架构设计方法，通过将应用程序功能模块化为可复用、独立部署的“**服务**”，并通过标准化的接口进行通信，实现系统的灵活性、可扩展性和可维护性。

* 核心思想：

  * **服务松耦合**：服务之间通过定义良好的接口通信，降低系统间的依赖性。
  * **服务复用性**：服务可被多个应用或系统调用，减少重复开发。
  * **服务自治性**：每个服务独立运行，拥有自己的数据和逻辑。
  * **服务可组合性**：服务可通过编排组合成新的业务流程。
  * **标准化通信协议**：服务间通信基于标准协议（如HTTP、SOAP、REST、MQ等）。

* 抽取出来的服务集群由谁来管理呢？这就牵扯出了另一个概念：服务治理。

* **服务治理的方案**：

  * 注册中心：对服务集群进行管理。集群中的每个服务是否健康等。
  * 负载均衡：web门户访问这个集群时，由哪个订单模块来提供服务。
  * 容错：某个模块出错了，切换到有效的模块提供服务。
  * 配置中心：每个订单模块都需要做配置，配置中心可以统一更改所有模块的配置。
  * 限流

* 企业服务总线ESB 

  ![image-20250516163648935](F:\JavaCode\Dubbo\document\image\image-20250516163648935.png)

  * 作为中间件，负责服务间的路由、协议转换、数据格式转换等。
  * 例如：IBM MQ、Apache Camel。
  * 分为同步的调用(通过protobuf、thfit IDL)和异步调用（通过MQ的方式）



### 1.2.6 微服务架构

* 什么是微服务架构？

  ​		微服务是SOA架构的升级，在微服务体系统中，没有⼦系统了，全部都是服务化功能。微服务架构代表框架，SpringCloud,DNS。

  ​		如今微服务已经可以和SOA架构等同了，微服务就是将SOA做到了机制。

  ​		微服务将单体架构的缺点完全解决了。

![image-20250516164432496](F:\JavaCode\Dubbo\document\image\image-20250516164432496.png)







# 二. Dubbo概述

## 2.1 什么是Dubbo

* 早期Dubbo的定位

  ​		Dubbo的核心定位是一个基于JAVA的⾼性能的分布式 RPC 框架，其设计目标是简化远程服务调用，提供透明化的远程过程调用（Remote Procedure Call）能力。

  ​		Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的 **RPC** 远程服务调用方案、服务治理方案。

* 三大核心功能

  * 面向接口的远程方法调用，
  * 智能容错和负载均衡，
  * 服务自动注册和发现。

* dubbo 的前世今生

  * dubbo 之前一直都作为 Alibaba 公司内部使用的框架。

  * 2011 年,dubbo 被托管到了 GitHub 上(开源)

  * 2014年11月发布2.4.11版本后宣布停止更新。此后一段时间很多公司开源了自己基于Dubbo的变种版本(例如当当网的 Dubbo X,网易考拉的 Dubbo K）

  * 2017 年 SpringCloud 横空出世,Dubbo 感觉到压力后连续更新了几个版本

  * 2018 年 1 月,阿里公司联合当当网将 Dubbo 和 Dubbo X 合并,发布了 2.6 版本

  * 2018 年除夕夜阿里将 Dubbo 贡献给了 Apache 基金会。Apache 维护和更新 Dubbo，正式更名为

    Apache Dubbo。最新版本为Dubbo3.x。

  * **Apache Dubbo 是⼀款易⽤、⾼性能的 WEB 和 RPC 框架，同时为构建企业级微服务提供服务发现、流量治理、可观测、认证鉴权等能⼒、⼯具与最佳实践。**

* DNS是什么

  ​		Dubbo3 已在阿⾥巴巴内部微服务集群全⾯落地，成功取代运⾏多年的HSF 框架。依托于Dubbo3,阿⾥提出了⾃⼰的微服务解决⽅案DNS（Dubbo + nacos + sentinel）。

* 经过孵化，Dubbo⽬前成为Apache的顶级项⽬。

  * 官方网站:https://dubbo.apache.org/zh-cn/
  * GitHub :https://github.com/apache/dubbo



## 2.2 为什么Dubbo说自己性能高

​		高性能要从底层的原理说起，既然是一个 RPC框架，主要干的就是远程过程(方法)调用，那么提升性能就要从最关键、最耗时的两个方面入手：序列化和网络通信。

​		序列化：我们学习 Java 网络开发的时候知道,本地的对象要在网络上传输，必须要实现Serializable 接口，也就是必须序列化。我们序列化的方案很多：xml、json、二进制流…其中效率最高的就是二进制流(因为计算机就是二进制的)。然而 Dubbo 采用的就是效率最高的二进制。

​		网络通信：不同于 HTTP 需要进行 7 步走(三次握手和四次挥手)，Dubbo 采用 Socket 通信机制,一步到位,提升了通信效率,并且可以建立长连接,不用反复连接,直接传输数据。



## 2.3 Dubbo3升级的核心内容

* 易用性

  * 开箱即用，易用性高，如Java版本的面向接口代理特性能实现本地透明调用，功能丰富，基于原生库或轻量扩展即可实现绝大多数的微服务治理能力。更加完善了多语言支持。

* 超大规模微服务实践

  * 高性能通信 （Triple GRPC）
  * 高可扩展性（SPI多种序列化方式 多种协议）
  * 丰富的服务治理能力
  * 超大规模集群实例水平扩展

* 云原生友好 (本地开发的程序，不经任何修改或很少的修改就可以上到云环境中)

  * 容器调度平台（Kubernetes）：将服务的组织与注册交给底层容器平台，如Kubernetes，这是更云原生的方式。

  * 服务网格Service Mesh：原有Mesh结构中通过Sidecar完成负载均衡、路由等操作，但是存在链路的性能损耗⼤，现有系统迁移繁琐等问题。Dubbo3引⼊Proxyless Mesh，直接和控制面交互[istio]通信。集成

    ServiceMesh更为方便，效率更高。



## 2.4 基本架构

![image-20250516174234803](F:\JavaCode\Dubbo\document\image\image-20250516174234803.png)

* **服务提供者（Provider）**：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。
* **服务消费者（Consumer）**: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
* **注册中心（Registry）**：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
* **监控中心（Monitor）**：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心

调用关系说明：

0. 服务容器负责启动，加载，运行服务提供者。

1. 服务提供者在启动时，向注册中心注册自己提供的服务。
2. 服务消费者在启动时，向注册中心订阅自己所需的服务。
3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。



## 2.5 dubbo支持的协议

​		上述调用过程中第4步，消费者调用服务提供者的服务时，需要遵守一些协议。支持多种协议：dubbo , hessian , rmi , http, webservice , thrift , memcached , redis。

​		dubbo 官方推荐使用 dubbo 协议。dubbo 协议默认端口 20880。